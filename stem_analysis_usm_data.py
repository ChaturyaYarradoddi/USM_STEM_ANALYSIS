# -*- coding: utf-8 -*-
"""Stem_Analysis USM_Data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XlkEdP3J-Vq4TUAgrFhJxx_TRw4KxOoK
"""

import pandas as pd
import numpy as np
import seaborn as sns
pd.set_option('display.max_columns', 107)
pd.set_option('display.max_rows', 13693)

# Load the decrypted file into a pandas DataFrame
df = pd.read_excel("/content/USM FY 2014 New FT and Transfers Retention Degree and FA  12-21-23 (1) (1)(1).xlsx")

# Display the first few rows
print(df.head())

df.info()

df['Plan1_1'].unique()

"""## Total count of students in a dataset:**13694**
## Total number of students Graduated: **9388**
## Total number of students not Graduated: **4306**

## Total number students whose initial major and final reported major are the same(regardless of graduation status):**6750**

## Total number of students whose initial major and final reported major are not the same (regardless of graduation status): **6944**
## Total number students whose initial major and final reported major are the same and grduated :**4049**

## Total number of students whose initial major and final reported major are not the same and grduated :**5339**

"""

# Count students who graduated
graduated_count = df[df['Graduated'] == 'Yes']['StudentKey'].nunique()

# Count students who did not graduate
not_graduated_count = df[df['Graduated'] != 'Yes']['StudentKey'].nunique()

# Display the results
graduation_summary = {
    "Total Graduated Students": graduated_count,
    "Total Not Graduated Students": not_graduated_count
}

graduation_summary

# Create a new column to check if the initial major (Plan1_1) is the same as the final reported major (LastrptgPlanShortDescr)
df['Same_Initial_Final_Major'] = df.apply(lambda x: 1 if str(x['Plan1_1']).strip().lower() == str(x['LastrptgPlanShortDescr']).strip().lower() else 0, axis=1)

# Count how many students kept their original major versus those who changed
same_major_count = df['Same_Initial_Final_Major'].sum()
changed_major_count = len(df) - same_major_count

# Display the results
major_change_summary = {
    "Students Who Kept Their Initial Major": same_major_count,
    "Students Who Changed Their Major": changed_major_count
}

major_change_summary

# Filter only students who graduated
graduated_df = df[df['Graduated'] == 'Yes']

# Create a new column to check if the initial major (Plan1_1) is the same as the final reported major (LastrptgPlanShortDescr) for graduates
graduated_df['Same_Initial_Final_Major'] = graduated_df.apply(
    lambda x: 1 if str(x['Plan1_1']).strip().lower() == str(x['LastrptgPlanShortDescr']).strip().lower() else 0, axis=1
)

# Count how many graduates kept their original major versus those who changed
same_major_count = graduated_df['Same_Initial_Final_Major'].sum()
changed_major_count = len(graduated_df) - same_major_count

# Display the results
graduated_major_change_summary = {
    "Graduates Who Kept Their Initial Major": same_major_count,
    "Graduates Who Changed Their Major": changed_major_count
}

graduated_major_change_summary

"""## **Individual count of Students who started and final reported major are same or not (regardless of graduation status)**"""

# Count of students who started and ended with the same major
same_major_counts = df[df['Same_Initial_Final_Major'] == 1].groupby('Plan1_1')['StudentKey'].count()

# Count of students who started with one major but ended with another
changed_major_counts = df[df['Same_Initial_Final_Major'] == 0].groupby(['Plan1_1', 'LastrptgPlanShortDescr'])['StudentKey'].count()

# Convert results to DataFrames for better readability
same_major_df = same_major_counts.reset_index().rename(columns={'StudentKey': 'Count_Started_Ended_Same_Major'})
changed_major_df = changed_major_counts.reset_index().rename(columns={'StudentKey': 'Count_Changed_Major'})

same_major_df

changed_major_df

"""## **Individual count of Students who started and final reported major and graduated are same or not**"""

# Count of students who started and ended with the same major among graduates
same_major_counts = graduated_df[graduated_df['Plan1_1'] == graduated_df['LastrptgPlanShortDescr']].groupby('Plan1_1')['StudentKey'].count()

# Count of students who started with one major but ended with another among graduates
changed_major_counts = graduated_df[graduated_df['Plan1_1'] != graduated_df['LastrptgPlanShortDescr']].groupby(['Plan1_1', 'LastrptgPlanShortDescr'])['StudentKey'].count()

# Convert results to DataFrames for better readability
same_major_df = same_major_counts.reset_index().rename(columns={'StudentKey': 'Count_Started_Ended_Same_Major'})
changed_major_df = changed_major_counts.reset_index().rename(columns={'StudentKey': 'Count_Changed_Major'})

same_major_df

changed_major_df

"""# **STEM MAJORS**"""

# Define the list of STEM majors based on the provided document
stem_majors = [
    "Mathematics", "Bioc & Mol Biol", "Mech Eng", "Biol Sci",
    "Info Sys", "Comp Eng", "Environ Sci", "Chemical Eng",
    "Engineering", "Comp Sci", "Chemistry", "Environ Std",
    "Physics", "Statistics", "Binf & Comp Bio", "Bus Tech Admin",
    "Chemistry Educ", "Physics Educ", "Pre-Engineering",
    "Pre-Chem Eng", "Pre-Comp Sci", "Pre-Comp Eng", "Pre-Mech Eng",
    "Biol Educ", "Geog & Env Std", "Environ Sci & Geog",
    "Trnsltnl Life Sci Tech"
]

# Count total students
total_students = df['StudentKey'].nunique()

# Count students who started in STEM (Plan1_1 in STEM majors)
students_started_stem = df[df['Plan1_1'].isin(stem_majors)]['StudentKey'].nunique()

# Count students who started in STEM and graduated
students_started_stem_graduated = df[
    (df['Plan1_1'].isin(stem_majors)) & (df['Graduated'] == 'Yes')
]['StudentKey'].nunique()

# Count students who started in STEM, ended in STEM, and graduated
students_started_ended_stem_graduated = df[
    (df['Plan1_1'].isin(stem_majors)) &  # Started in STEM
    (df['LastrptgPlanShortDescr'].isin(stem_majors)) &  # Ended in STEM
    (df['Graduated'] == 'Yes')  # Graduated
]['StudentKey'].nunique()

# Count students who started in STEM, ended in NOT STEM, and graduated
students_started_stem_ended_nonstem_graduated = df[
    (df['Plan1_1'].isin(stem_majors)) &  # Started in STEM
    (~df['LastrptgPlanShortDescr'].isin(stem_majors)) &  # Ended in NON-STEM
    (df['Graduated'] == 'Yes')  # Graduated
]['StudentKey'].nunique()

# Display the results
summary_counts = {
    "Total Students": total_students,
    "Students Who Started in STEM": students_started_stem,
    "Students Who Started in STEM and Graduated(Any Major)": students_started_stem_graduated,
    "Students Who Started, Ended in STEM, and Graduated": students_started_ended_stem_graduated,
    "Students Who Started in STEM, Ended in Non-STEM, and Graduated": students_started_stem_ended_nonstem_graduated
}

summary_counts

"""# **Support**"""

df['totalsupport'] = df.loc[:,'Y1GrantAmount':'Y6MeritAmount'].sum(1)
df['supportedY1'] = df.apply(lambda x: 1 if (x['Y1GrantAmount'] + x['Y1MeritAmount'] != 0) else 0, axis = 1)
df['supported'] = df.apply(lambda x: 1 if (x['totalsupport'] != 0) else 0, axis = 1)
df[['supported']].value_counts()

"""## **Financial need category (Y1Need) and support status (supported) for STEM students**"""

# Filter students who started in STEM, ended in STEM, and graduated
stem_students = df[
    (df['Plan1_1'].isin(stem_majors)) &  # Started in STEM
    (df['LastrptgPlanShortDescr'].isin(stem_majors)) &  # Ended in STEM
    (df['Graduated'] == 'Yes')  # Graduated
]

# Group by financial need category (Y1Need) and support status (supported) for these students
support_by_need_stem = stem_students.groupby(['Y1Need', 'supported'])['StudentKey'].count().reset_index()

support_by_need_stem = support_by_need_stem.rename(columns={
    'Y1Need': 'Financial Need Category',
    'supported': 'Support Status',
    'StudentKey': 'Student Count'
})

support_by_need_stem

# Function to determine if any degree date columns are not null (indicating graduation)
def check_graduation(row):
    # Check each degree date column for non-null values
    for i in range(1, 5):  # Assuming you have degreedate1 to degreedate4
        if pd.notnull(row[f'degreedate{i}']):
            return 'Yes'
    return 'No'

#Function to see if the degree obtained was in STEM
hegisstem = ('7','9','4','17','19');

myctr = 0;
def check_stem(row):
  #ctr = 0;
  if (str(row['EntryMajor']).startswith(hegisstem)):
    #print("found 17");
    return 'Yes';
  #print();
  return 'No';


# Apply the function to create the "Graduated" column
print('Total Students: ', len(df.index));
df['Graduated'] = df.apply(check_graduation, axis=1);
print('Total Graduated: ', len(df[df['Graduated'] == 'Yes']))
df['Stem1'] = df.apply(check_stem, axis=1);
#df['stem2stem'] = df.apply(lambda x: 1 if (x['Stem1'] == 'Yes') and (x['HegisDeg1'] == 'Yes') else 0, axis=1)
print('Stem Majors: ', (df.Stem1.values == 'Yes').sum());
print ('Stem Majors Graduated: ', len(df[(df['Stem1'] == 'Yes') & (df['Graduated'] == 'Yes')]))
#print (len(df[(df['Graduated'] == 'Yes']) && (df['Stem1'] == 'Yes')))

# Save the updated DataFrame to a new CSV file
df.to_csv('updated_file.csv', index=False);
#print(df.head(5));

# Identify rows where entrydegreeseeking is 'Non-Degree undergrad'
rows_to_drop = df[df['entrydegreeseeking'] == 'Non-Degree undergrad'].index

# Drop these rows from the DataFrame
df.drop(rows_to_drop, inplace=True)
print('After we drop non degree seeking students')

# Now df contains only the rows where entrydegreeseeking is not 'Non-Degree undergrad'
# You can continue your analysis using df without saving it to a new CSV file

# Calculate total support across specified years
# df['totalsupport'] = df.loc[:, 'GrantAmountFY2014':'MeritAmountFY2022'].sum(axis=1)
if all(col in df.columns for col in ['GrantAmountFY2014', 'MeritAmountFY2022']):
   df['totalsupport'] = df.loc[:, 'GrantAmountFY2014':'MeritAmountFY2022'].sum(axis=1)
else:
   print("Required columns for totalsupport calculation are missing.")

# Indicate if supported in FY2014
df['supportedY1'] = df.apply(lambda x: 1 if (x['GrantAmountFY2014'] + x['MeritAmountFY2014'] != 0) else 0, axis=1)

# Indicate if supported at all based on 'totalsupport'
df['supported'] = df.apply(lambda x: 1 if (x['totalsupport'] != 0) else 0, axis=1)

# Indicate if graduated
df['grdnum'] = df.apply(lambda x: 1 if (x['Graduated'] == 'Yes') else 0, axis=1)
print('Number of Students: ', len(df.index));
print('Number of Stem Students: ', (df.Stem1.values == 'Yes').sum());
#print(df.head(5));
#print('StemGradRates')
print ('STEM Graduates: ', len(df[(df['Stem1'] == 'Yes') & (df['Graduated'] == 'Yes')]))

# Group students by EFC category and Year 1 support status
efc_support_total_students = df.groupby(['EFC_Category', 'supportedY1']).size()
efc_support_stem_entrants = df[df['Stem1'] == 'Yes'].groupby(['EFC_Category', 'supportedY1']).size()
efc_support_stem_completed = stem_to_stem_df.groupby(['EFC_Category', 'supportedY1']).size()

# Calculate STEM Entry Rate from Total Students
stem_entry_rate_from_total = (efc_support_stem_entrants / efc_support_total_students) * 100

# Calculate STEM Completion Rate from STEM Entrants
stem_completion_rate_from_entrants = (efc_support_stem_completed / efc_support_stem_entrants) * 100

# Calculate STEM Completion Rate from Total Students
stem_completion_rate_from_total = (efc_support_stem_completed / efc_support_total_students) * 100

# Create a DataFrame for the calculations
efc_stem_analysis_df = pd.DataFrame({
    'Total_Students': efc_support_total_students,
    'STEM_Entrants': efc_support_stem_entrants,
    'STEM_To_Stem_Completed': efc_support_stem_completed,
    'STEM_Entry_Rate_From_Total': stem_entry_rate_from_total,
    #'STEM_To_Stem_Completion_Rate_From_Entrants': stem_completion_rate_from_entrants,
    #'STEM_To_Stem_Completion_Rate_From_Total': stem_completion_rate_from_total
}).fillna(0)  # Fill NaN values with 0

efc_stem_analysis_df

# Function to categorize EFC values, including handling nulls
def categorize_efc(efc):
    if pd.isnull(efc):
        return 'Unknown'  # Handle null values explicitly
    elif efc < 6657 :
        return 'High'
    elif 6657 <= efc <= 13312 :
        return 'Medium'
    else:  # EFC > 13312
        return 'Low'

# Apply the function to the EFC column to create a new category column
df['EFC_Category'] = df['EFC'].apply(categorize_efc)
print(df.head(5));

efc_category_counts = df["EFC_Category"].value_counts()
print(efc_category_counts)

# Ensure totalsupport is in a numeric format, in case it's not
df['totalsupport'] = pd.to_numeric(df['totalsupport'], errors='coerce')

#check the shape of the data
print(df.shape)

# Drop rows where totalsupport is NaN after conversion
df.dropna(subset=['totalsupport'], inplace=True)
print(len(df.index))

# Define bins for support levels
bins = [0,1, 5000, 10000, 15000, 20000, np.inf]
labels = ['NoSup','<5K', '5K-10K', '10K-15K', '15K-20K', '>20K']
df['support_bin'] = pd.cut(df['totalsupport'], bins=bins, labels=labels, right=False)
#print(df.head(5));
# Count the number of students in each bin
student_counts = df['support_bin'].value_counts().sort_index()

# Print the results
print('Students in different support bins:\n', student_counts)

# Filter students who started and ended in STEM
stem_to_stem_df = df[
    (df['EntryMajor'].astype(str).str.startswith(tuple(hegisstem))) &
    (df['HegisDeg1'].astype(str).str.startswith(tuple(hegisstem))) &
    (df['Graduated'] == 'Yes')
]
stem_allstem_df = df[
    (df['HegisDeg1'].astype(str).str.startswith(tuple(hegisstem))) &
    (df['Graduated'] == 'Yes')
]
stem_graduates = len(df[(df['Stem1'] == 'Yes') & (df['Graduated'] == 'Yes')])


# Count calculations
total_students = len(df)  # Total students in dataset
total_stem_students = (df['Stem1'] == 'Yes').sum()  # Total students who entered in STEM
stem_to_stem_count = len(stem_to_stem_df)  # Students who started & ended in STEM
#stem_graduates = len(df[(df['Stem1'] == 'Yes') & (df['Graduated'] == 'Yes')])  # STEM students who graduated
stem_all=len(stem_allstem_df )

# Percentage calculations
percentage_of_total_students = (stem_to_stem_count / total_students) * 100
percentage_of_stem_students = (stem_to_stem_count / total_stem_students) * 100
percentage_of_stem_students_grad = (stem_to_stem_count / stem_graduates) * 100
percentage_of_stem_students_grad_all = (stem_all / total_students) * 100


# Display results
print(f"Total Students: {total_students}")
print(f"Total STEM Entry Students: {total_stem_students}")
print(f"Total STEM grad all: {stem_all}")
print(f"Students Who Started and Ended in STEM: {stem_to_stem_count}")
print(f"Percentage of Total Students: {percentage_of_total_students:.2f}%")
print(f"Percentage of STEM Entry Students: {percentage_of_stem_students:.2f}%")
print(f"Percentage of STEM grad_all: {percentage_of_stem_students_grad_all:.2f}%")

#print(f"Percentage of STEM Graduates (7660): {percentage_of_stem_students_grad:.2f}%")

# Parallel calculations

# STEM Entry Rate from Total Students
efc_stem_entry_rate_from_total = (efc_stem_entrants / efc_total_students) * 100

# STEM Completion Rate from STEM Entrants in the same category
efc_stem_completion_rate_within_entrants = (efc_stem_completed / efc_stem_entrants) * 100

# STEM Completion Rate from Total Students in the same category
efc_stem_completion_rate_within_total = (efc_stem_completed / efc_total_students) * 100

# Create DataFrame for parallel calculations
parallel_calculations_df = pd.DataFrame({
    'Total_Students': efc_total_students,
    'STEM_Entrants': efc_stem_entrants,
        'STEM_To_Stem_Completed': efc_stem_completed,

    'STEM_Entry_Rate_From_Total': efc_stem_entry_rate_from_total,
    'STEM_Completion_Rate_Within_Entrants': efc_stem_completion_rate_within_entrants,
    'STEM_Completion_Rate_Within_Total': efc_stem_completion_rate_within_total
}).fillna(0)  # Fill NaN with 0 for missing categories

# Display the parallel calculations DataFrame
parallel_calculations_df

# Calculate STEM Completion Rate from STEM Entrants
stem_completion_rate_from_entrants = (efc_support_stem_completed / efc_support_stem_entrants) * 100

# Calculate STEM Completion Rate from Total Students
stem_completion_rate_from_total = (efc_support_stem_completed / efc_support_total_students) * 100

# Calculate STEM Entry Rate from Total Students
stem_entry_rate_from_total = (efc_support_stem_entrants / efc_support_total_students) * 100

# Create a combined DataFrame for parallel calculations
combined_parallel_calculations_df = pd.DataFrame({
    'Total_Students': efc_support_total_students,
    'STEM_Entrants': efc_support_stem_entrants,
    'STEM_To_Stem_Completed': efc_support_stem_completed,
    'STEM_Entry_Rate_From_Total': stem_entry_rate_from_total,
    'STEM_To_Stem_Completion_Rate_From_Entrants': stem_completion_rate_from_entrants,
    'STEM_To_Stem_Completion_Rate_From_Total': stem_completion_rate_from_total
}).fillna(0)  # Fill NaN values with 0

combined_parallel_calculations_df

# For Supported (1) group
supported_stem_to_stem_count = parallel_calculations_df.loc[(['High', 'Low', 'Medium'], 1), 'STEM-to-STEM Count'].sum()
supported_stem_entry_count = efc_support_stem_entry_count.loc[(['High', 'Low', 'Medium'], 1)].sum()
supported_stem_total_count = parallel_calculations_df.loc[(['High', 'Low', 'Medium'], 1), 'STEM TOTAL Count'].sum()

# For Not Supported (0) group
not_supported_stem_to_stem_count = parallel_calculations_df.loc[(['High', 'Low', 'Medium'], 0), 'STEM-to-STEM Count'].sum()
not_supported_stem_entry_count = efc_support_stem_entry_count.loc[(['High', 'Low', 'Medium'], 0)].sum()
not_supported_stem_total_count = parallel_calculations_df.loc[(['High', 'Low', 'Medium'], 0), 'STEM TOTAL Count'].sum()

# STEM-to-STEM Count / STEM Entry Count for each group
supported_stem_to_stem_ratio = (supported_stem_to_stem_count / supported_stem_entry_count) * 100
not_supported_stem_to_stem_ratio = (not_supported_stem_to_stem_count / not_supported_stem_entry_count) * 100

# STEM-to-STEM Count / STEM TOTAL Count for each group
supported_stem_to_stem_total_ratio = (supported_stem_to_stem_count / supported_stem_total_count) * 100
not_supported_stem_to_stem_total_ratio = (not_supported_stem_to_stem_count / not_supported_stem_total_count) * 100

print("===== STEM-to-STEM Ratios =====")
print(f"STEM-to-STEM % of STEM Entry (Supported): {supported_stem_to_stem_ratio:.2f}%")
print(f"STEM-to-STEM % of STEM Entry (Not Supported): {not_supported_stem_to_stem_ratio:.2f}%")

print("\n===== STEM-to-STEM Ratios (Total STEM Students) =====")
print(f"STEM-to-STEM % of Total STEM (Supported): {supported_stem_to_stem_total_ratio:.2f}%")
print(f"STEM-to-STEM % of Total STEM (Not Supported): {not_supported_stem_to_stem_total_ratio:.2f}%")

# Group students by EFC category and Year 1 support status
efc_support_total_students = df.groupby(['EFC_Category', 'supportedY1']).size()
efc_support_stem_entrants = df[df['Stem1'] == 'Yes'].groupby(['EFC_Category', 'supportedY1']).size()
efc_support_stem_completed = stem_to_stem_df.groupby(['EFC_Category', 'supportedY1']).size()

# Calculate STEM Entry Rate from Total Students
stem_entry_rate_from_total = (efc_support_stem_entrants / efc_support_total_students) * 100

# Calculate STEM Completion Rate from STEM Entrants
stem_completion_rate_from_entrants = (efc_support_stem_completed / efc_support_stem_entrants) * 100

# Calculate STEM Completion Rate from Total Students
stem_completion_rate_from_total = (efc_support_stem_completed / efc_support_total_students) * 100

# Create a DataFrame for the calculations
efc_stem_analysis_df = pd.DataFrame({
    'Total_Students': efc_support_total_students,
    'STEM_Entrants': efc_support_stem_entrants,
    'STEM_To_Stem_Completed': efc_support_stem_completed,
    'STEM_Entry_Rate_From_Total': stem_entry_rate_from_total,
    'STEM_To_Stem_Completion_Rate_From_Entrants': stem_completion_rate_from_entrants,
    'STEM_To_Stem_Completion_Rate_From_Total': stem_completion_rate_from_total
}).fillna(0)  # Fill NaN values with 0

efc_stem_analysis_df

